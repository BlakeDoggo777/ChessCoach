<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Technical explanation | ChessCoach</title>

    <link href="github-markdown.css" rel="stylesheet" />
    <link href="site.css" rel="stylesheet" />
</head>
<body class="markdown-body">
    <article class="content">
        <div class="contents">
            <div class="contents-body">
                <div id="header" class="contents-part">
                    <h3>ChessCoach</h3> <span id="by-narrow">– <a href="mailto:chris.butner@outlook.com">Chris Butner</a></span>
                    <p>A neural network-based chess engine capable of natural language commentary</p>
                    <p id="by-wide"><a href="mailto:chris.butner@outlook.com">Chris Butner</a></p>
                </div>
                <div id="inter" class="contents-part compact">
                    <p><a href="index.html">Overview</a></p>
                    <p><a href="high-level-explanation.html">High-level explanation</a></p>
                    <p><strong><a href="technical-explanation.html">Technical explanation</a></strong></p>
                    <p><a href="development-process.html">Development process</a></p>
                    <p><a href="data.html">Data</a></p>
                    <p><a href="https://github.com/chrisbutner/ChessCoach#readme">Code and Installation (GitHub)</a></p>
                    <p><a href="https://lichess.org/@/PlayChessCoach">@PlayChessCoach (Lichess)</a></p>
                </div>
                <div id="intra" class="contents-part compact">
                    <p><a href="#introduction">Introduction</a></p>
                    <p><a href="#software-design-rationale">Software design rationale</a></p>
                    <p><a href="#chess-position-management">Chess position management</a></p>
                    <p><a href="#neural-network-training">Neural network training</a></p>
                    <p><a href="#neural-network-inference">Neural network inference</a></p>
                    <p><a href="#commentary-training-and-inference">Commentary training and inference</a></p>
                    <p><a href="#self-play">Self-play</a></p>
                    <p><a href="#distributed-training-and-self-play">Distributed training and self-play</a></p>
                    <p><a href="#tournament-play">Tournament play</a></p>
                    <p><a href="#tournament-play-techniques">Tournament play techniques</a></p>
                    <p><a href="#configuration-management">Configuration management</a></p>
                    <p><a href="#prediction-cache-transposition-table">Prediction cache, transposition table</a></p>
                    <p><a href="#data-pipelines-and-storage">Data pipelines and storage</a></p>
                    <p><a href="#cpp-and-python-interoperation">C++ and Python interoperation</a></p>
                    <p><a href="#debug-gui">Debug GUI</a></p>
                    <p><a href="#portability">Portability</a></p>
                    <p><a href="#strength-testing">Strength testing</a></p>
                    <p><a href="#parameter-optimization">Parameter optimization</a></p>
                    <p><a href="#bot">Bot</a></p>
                    <p><a href="#scraping">Scraping</a></p>
                    <p><a href="#unit-tests">Unit tests</a></p>
                    <p><a href="#build">Build</a></p>
                    <p><a href="#third-party-libraries">Third-party libraries</a></p>
                </div>
            </div>
        </div>

        <h1>Technical explanation</h1>

        <h2 id="introduction">Introduction</h2>
        <p>I have already covered many technical details in the high-level explanation, so I will try to make this document more code focused. If you have not read the <a href="high-level-explanation.html">High-level explanation</a>, feel free to refer back to individual sections as needed. The next section, <a href="#software-design-rationale">Software design rationale</a>, explains some of the design choices made in the codebase, but may not be too interesting to you. Instead, you can jump straight to the sections on feature areas, starting with <a href="#chess-position-management">Chess position management</a>.</p>

        <h2 id="software-design-rationale">Software design rationale</h2>
        <p>I try to take a practical approach with software design, focusing on concrete examples of how design choices can help individuals or teams while trying to avoid dogma. Some choices in ChessCoach may seem questionable at surface-level and would confuse the freshly graduated version of myself. I'll start with a really specific example.</p>
        <p>It is important in code commentary to focus not just on the &quot;why&quot;, but the &quot;what&quot;. Constantly switching between high level and low level, architecture and minutia, is a big part of what makes programming mentally taxing. Anything that allows others and future-you to stay above the low-level details while finding your way somewhere else is immensely helpful. Critics often say, &quot;the code should be self-documenting&quot; – sure, but that only goes so far. We speak in natural language because it is a better interface to our brains than code. Critics often ask, &quot;what if you change the code and the comment goes stale?&quot; Well, what if we only fix the reported repro of a bug, or skip writing unit tests, or debug in production? Skilled work requires care and proactivity. Providing information and guidance rather than micromanaging with guard rails usually wins out.</p>
        <p>Code is read many more times than it is written, and investments into readability are worthwhile even if they feel wrong to the part of our brain that craves structure and hands-off reliability. It is common to see a trivial example saying, &quot;see, this comment just repeats exactly what the code says&quot; – and sure, I agree that this is often useless – but extrapolating this to &quot;comment why, not what&quot; is harmful and lazy. We don't question the value of highways when surface streets exist. We don't question the value of exit markers and street signs when all of that info is on Google Maps. The mental tax in scanning other people's code, with varying subject matter, approaches, languages and styles, is underestimated. Redundancy is all around us, and often very useful.</p>
        <p>This principle of acceptable redundancy applies in other areas. It is okay to copy and paste code if the redundancy is coincidental or temporary. It is okay to write your own code instead of depending on someone else's with extra features and no test coverage. It is okay to store versions of the truth in two different places if the alternative would be worse. It is okay to wait to consolidate logic or automate systems until enough examples exist to show the right way to do so.</p>
        <p>Short, bloggable principles that assert themselves universally give us a cozy feeling that we're smart and doing the right thing. Explanations are often logical in isolation, or at least persuasive. However, we need to consider costs and benefits to real people in concrete scenarios. Depending on the workplace and environment, this can take courage.</p>
        <p>Beyond the locus of redundancy, there are other instances of programming dogma worth examining. It is good to see questioning of object-oriented design in recent times, especially when these reevaluations are themselves pragmatic and self-aware. <a href="http://number-none.com/blow/john_carmack_on_inlined_code.html">John Carmack (2007)</a> explains the benefits of larger, cohesive blocks of code as opposed to extracting small pieces in the fashion of self-documentation and hypothetical reuse. <a href="https://www.youtube.com/watch?v=pW-SOdj4Kkk">Jonathan Blow (2019a)</a> <a href="https://www.youtube.com/watch?v=dS6rCaDSwW8">(2019b)</a> <a href="https://www.youtube.com/watch?v=JjDsP5n2kSM">(2013)</a> takes a thoughtful, grounded approach when discussing many problematic aspects of modern software development.</p>

        <p>With ChessCoach, I have tried to follow these principles where they make sense:</p>
        <ul>
            <li>Write simple systems, without unnecessary abstraction, indirection or layering</li>
            <li>Define clear milestones and build the minimum now</li>
            <li>Keep related code together</li>
            <li>Wait to abstract, combine or automate until enough examples guide a clear approach</li>
            <li>Write code and comments instructively, targeting a less technical audience when possible</li>
            <li>Prefer clarity in naming, explanation and design to looking clever</li>
            <li>Choose boring technology</li>
        </ul>

        <p>I'm satisfied with the way some of the design turned out. The system of flexibly arranged training stages saved time when running many experiments. Implementing the bare minimum of coroutines through three or four in-band function returns served a year of development without messing with libraries. A few key object abstractions such as chess games and worker groups helped with mental mapping. It was nice ending up with a single threading model to handle self-play and tournament play. Self-play and training performance hit the necessary targets. Unit tests give reasonable coverage.</p>
        <p>I'm dissatisfied with a larger number of items. The code is nowhere near the clean and minimal aesthetic you often see in classical engines. Configuration is somewhat of a disaster, as while some aspects such as automatic optimization/option mapping and parsing policies were convenient, parsing and storing in two languages to avoid an API boundary probably ended up much worse. While it initially made sense to parse PGNs internally because going from an intermediate format to a training format is about the same complexity, by the time variations and commentary were required, an external tool may have been better. SelfPlay.cpp ended up too big even by my standards: while a lot of it belongs together, some of it is there just to work around link-time optimization failures, and some could be split out with enough care. However, I think a crude self-play/tournament or search/game split would end up counterproductive. Code calling in to Python contains a lot of boilerplate that convenience utilities could take care of, although I try to avoid templating. Systems like parameter optimization and strength testing sometimes use code hosting and sometimes use process hosting to work around hardware ownership issues. CPU and memory optimizations are incomplete and inconsistent. Tracing and debugging infrastructure you may be accustomed to in a large company is non-existent. Package management is the bare minimum required to compile. Builds link in too much and do not always follow the spirit of the framework. On reflection, however, I believe that many dissatisfying design areas still gave the project the right amount of support on the way to the finish line without veering into over-engineering.</p>

        <h2 id="chess-position-management">Chess position management</h2>
        <p>Stockfish code is used to manage the low-level technical details of chess positions, rules and moves. The ChessCoach Game<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.h#L45">[1]</a> class wraps the Stockfish Position<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L72">[2]</a> and StateInfo<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L37">[3]</a> classes. It also takes care of generating and processing input and output data for the neural network, since this data is closely tied to the low-level details of the position, including the Position's Bitboards<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L194">[4]</a>. Since the neural network depends on the previous seven positions in the form of history planes, the Game class implements an efficient way to walk back through them<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.h#L223">[5]</a>. Classical engines are not normally required to reapply moves, so small modifications are made in Stockfish code<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L148">[6]</a> to make it more efficient.</p>
        <p>ChessCoach also often needs to branch a <em>scratch</em> game off the real game and run through hypothetical moves; for example, when running self-play simulations. Stockfish positions use a list of StateInfo<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L63">[7]</a> objects to manage rules such as threefold repetition, 50-move draws, and en passant, especially when rolling back a move during search. The Game class avoids duplicating these lists in scratch games and instead creates new &quot;branches&quot; that point back to a main &quot;trunk&quot;<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L568">[8]</a>, using StateInfo's built-in pointer<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L52">[9]</a>.</p>
        <p>Because StateInfos have a fixed size they are pooled to help with performance and fragmentation. Nodes were also pooled previously, but this was reverted to allow for multi-threaded search. The pooling<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PoolAllocator.h#L49">[10]</a> is very primitive and offers little benefit over built-in allocators. More complicated schemes with better threaded deallocation could help, especially through a more contextually aware <em>arena</em> setup; for example, coupling StateInfo and Node lifetimes to games'.</p>

        <h2 id="neural-network-training">Neural network training</h2>
        <p>As training the neural network takes days to weeks, it is important to be able to pause and resume, and recover from network and hardware problems. Training teacher and student networks, and primary and commentary models also requires flexibility. ChessCoach uses a system of TrainingStages<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Config.h#L68">[1]</a> that are rotated through a series of checkpoints<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L146">[2]</a>. Resuming is based on on-disk evidence of stage completion<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTrain/ChessCoachTrain.cpp#L425">[3]</a> and just requires the ChessCoachTrain C++ binary to be re-run.</p>
        <p>ChessCoach uses the AlphaZero training schedule when running on a v3-8 Tensor Processing Unit (TPU), but adjusts to scale to different hardware. Parameters in config.toml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L136">[4]</a> define the exact schedule.</p>
        <p>TensorFlow 2 is used to define the models in functional form<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L140">[5]</a>, and checkpoints are saved and loaded as weights<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L387">[6]</a> rather than as serialized SavedModels.</p>
        <p>Training uses different distributed Strategies to abstract away hardware differences<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L91">[7]</a>: TPUStrategy, MirroredStrategy and the default. During training, models are initialized and compiled under the strategy scope<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L144">[8]</a> so that variables can be distributed to multiple devices as necessary.</p>
        <p>TensorFlow 2/Keras's Model.fit()<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L183">[9]</a> API with steps_per_execution<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L127">[10]</a> gives excellent training speed, but requires a few tricks. Model.fit() is quite opinionated in how a schedule is set up, with validation occurring after each epoch, so ChessCoach maps epochs to the validation interval<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L159">[11]</a> and hooks callbacks for console and TensorBoard logging<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L182">[12]</a> accordingly.</p>
        <p>Losses and metrics are fairly straightforward, although policy losses need to be flattened across rather than within planes<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L30">[13]</a>. The <em>MCTS value</em> auxiliary target is included at lower loss_weight<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L125">[14]</a>.</p>
        <p>Because the full model includes heads such as the commentary encoder<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L172">[15]</a>, a functional subset is taken for training<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L179">[16]</a> which interferes with saving and loading of optimizer state, including the number of training steps taken so far. Therefore, this information is manually added back before training<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L176">[17]</a>.</p>
        <p>Knowledge distillation uses a StudentModel subclass which overrides the default train_step and test_step <strong>on each replica</strong> by collecting a soft prediction from the teacher model<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L244">[18]</a> and incorporating it into loss calculations<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L38">[19]</a>.</p>
        <p>Validation is unorthodox. Rather than a training/validation split of the self-play data, which creates a chicken-and-egg problem in evaluating general chess understanding, ChessCoach uses a stationary supervised dataset for validation: the validation portion of the <a href="https://lczero.org/blog/2018/09/a-standard-dataset/"><em>CCRL Dataset</em> published by Lc0 (2018)</a>, based on <a href="https://ccrl.chessdom.com/ccrl/4040/about.html">Computer Chess Ratings Lists (CCRL)</a> data. Only a single, random batch is used for validation each interval<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L311">[20]</a>, so the results are volatile but over time give a visualization of the distribution in TensorBoard.</p>
        <p>Strength testing is also performed every few hours during training<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1258">[21]</a>, estimating an Elo rating using the Strategic Test Suite (STS) (Swaminathan, 2008; and Mosca, 2015), a set of 1,500 positions with varying points for the top four moves. The test takes five minutes to run, and results are logged to TensorBoard.</p>
        <p>The learning rate is reduced initially for a number of <em>warmup</em> steps<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L290">[22]</a>. Empirically, this ensures that the value head of the teacher network converges without requiring the number of bottleneck convolutional filters<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L42">[23]</a> to be expanded from 1, as in AlphaZero, to 8 or 32 as in projects such as KataGo and Lc0. Warmup reduces the magnitude of early gradient updates, especially when momentum is involved. Large updates can be harmful while the network is still deploying early structure.</p>
        <p>Stochastic weight averaging (SWA) is implemented by contributing each saved checkpoint to a decaying average<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L413">[24]</a>, and saving this average<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L436">[25]</a> as a separate checkpoint for inference. Just before saving the SWA model checkpoint, its batch normalization layers need to have their moving averages retrained<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L460">[26]</a>. Since these use an independent <em>momentum</em> parameter, this retraining can be performed using a learning rate of zero.</p>

        <h2 id="neural-network-inference">Neural network inference</h2>
        <p>Inference is using the neural network's full predictive powers, trusting in its training and ability to generalize on unseen inputs. It is also known as <em>prediction</em>, or <em>evaluation</em> in the high-level explanation. The network can generalize better and operate more efficiently during inference as layers like <em>batch normalization</em> and <em>dropout</em> focus on accuracy rather than training improvement; losses and gradients don't need to be calculated and remembered; parts of the calculation graph can be fused and optimized; and GPU/TPU devices don't have to synchronize with each other (although some workloads may still benefit from them collaborating).</p>
        <p>ChessCoach has N threads calling in to Python to predict batches of M positions each; for example, 8&nbsp;×&nbsp;256 on a v3-8 TPU. Each thread chooses a logical device from TensorFlow's GPU or TPU listing in round-robin fashion<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L522">[1]</a> and uses it as a tf.device context<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L542">[2]</a>. The model is called as a @tf.function to gain graph-mode speed-up<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L213">[3]</a>, and data is passed back to C++.</p>
        <p>Models are constructed and weights are loaded lazily<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L284">[4]</a> to speed initialization and save memory. Construction is locked globally<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L645">[5]</a> (empirically required by TensorFlow) and loading/assignment is locked per-device because CPython is still preemptive despite the GIL. As finding the best model weights to load can be complicated, utilities help with decision-making<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L481">[6]</a> and path comparison<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L162">[7]</a>. SWA models are preferred for prediction<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/config.py#L153">[8]</a> because of their improved generalization. Self-play threads continually check for new training checkpoints<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L262">[9]</a> in order to update inference model weights.</p>
        <p>Performance would likely be improved instead using the TensorFlow C++ API, with corresponding sacrifices to portability and readability. Currently, TensorFlow does not distribute their C++ API on Linux or Windows, <a href="https://github.com/tensorflow/tensorflow/issues/18360">citing a lack of bandwidth and asking for community development</a>. For example, a library such as GoogleTest can be linked against after installing the .h/.so via libgtest-dev on Linux, or downloading the .h/.lib/.dll on Windows via direct download or a package manager like NuGet or vcpkg. In contrast, TensorFlow must be built from source in the Bazel build tool with special flags, and linking projects must also use Bazel or try to narrow down exactly which artifacts are required in each version in order to transplant to another tool. Thankfully, the Python distribution is universal and consistent, so that is used instead.</p>

        <h2 id="commentary-training-and-inference">Commentary training and inference</h2>
        <p>The full commentary model<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L188">[1]</a> includes the tokenizer, the primary ChessCoach model as the encoder, and the transformer decoder. The decoder uses mostly-default transformer parameters<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L45">[2]</a>. An issue exists where TensorFlow cannot load weights for the commentary model because it cannot determine its shape. Therefore, the model is first <em>primed</em> on fake data<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L218">[3]</a>.</p>
        <p>The commentary decoder uses transformer code taken from the TensorFlow Model Garden, via the Python package tf-models-official. Some code references the installed package, and some code is copied into ChessCoach and extended<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/transformer.py#L80">[4]</a>. Embedding, encoding and masking are removed for inputs, and cross-attention masking is trivialized.</p>
        <p>The tokenizer maps between English words and sub-words, and integer token IDs. ChessCoach uses a vocabulary size of 8000 and trains a Sentencepiece tokenizer<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/tokenization.py#L32">[5]</a> over the raw commentary corpus. The TensorFlow Text library hosts the tokenizer at training and inference time, most importantly because the data pipeline needs to run in graph mode<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L258">[6]</a> (see Data pipelines and storage for more detail). However, a bug exists for detokenization on TPU during inference, so this is moved to CPU<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L558">[7]</a>.</p>
        <p>Data is split into 95% training and 5% validation by the ChessCoachPgnToGames<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachPgnToGames/ChessCoachPgnToGames.cpp#L177">[8]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.cpp#L530">[9]</a> tool, given the scarcity.</p>
        <p>As with the primary model, commentary training uses a Model.fit() approach<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L218">[10]</a> with steps_per_execution, with more tweaks. Default code would weight each training paragraph equally when calculating losses and backpropagating gradients. However, it is better instead to weight each word or sub-word equally. Some transformer code uses a custom training loop to achieve this in multi-GPU and TPU scenarios. Instead, ChessCoach applies sample weights in the data pipeline<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/transformer.py#L414">[11]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L309">[12]</a>. Padded cross-entropy loss is used with label smoothing of 10%<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/transformer.py#L396">[13]</a>.</p>
        <p>Optimization is also different for commentary. The Adam optimizer is commonly used for transformers instead of the stochastic gradient descent (SGD)-with-momentum combination that works well for convolutional models. ChessCoach uses Adam with a triangular <a href="https://arxiv.org/pdf/2004.02401.pdf">cyclical learning rate (CLR) (Lee, Liu &amp; Peng, 2020)</a> after range testing, with large batch size potential<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L294">[14]</a>. A v3-8 TPU allows for a schedule of 50,000 training batches of 4,096 positions each (configured as 400,000 batches of 512 positions each but divided and multiplied by the 8 devices). The overall schedule is approximately 233 epochs (the number of times the full training data is covered). The <em>step size</em> (half of a triangle/cycle) is approximately 11.65 epochs, with 10 cycles over the full schedule. Training finishes at the smallest learning rate. No explicit warmup is required because the learning rate already cycles up from the minimum for many epochs. Range testing pointed to a minimum Adam learning rate of 10<sup>-5</sup> and a maximum of 10<sup>-3</sup>. These parameters can be adjusted in config.toml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L153">[15]</a>. Training on GPUs is also possible but slow by comparison, with a maximum measured batch size of 64 per NVIDIA GeForce GTX 1080 and 128 per NVIDIA V100. Range testing needs to be re-run for each new hardware configuration.</p>
        <p>Validation is a little more orthodox for commentary and covers the full validation dataset. However, it is run every validation interval<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L145">[16]</a> of 250 batches, for a batch size of 4,096, rather than every epoch.</p>
        <p>Commentary inference uses the TensorFlow Model Garden's sampling code for top-p and temperature<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/transformer.py#L256">[17]</a>. ChessCoach applies a shim to work around a bug in top-p sampling on TPU<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/transformer.py#L426">[18]</a>. Dropout of 20%<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/model.py#L45">[2]</a> is used to balance generalization with specificity.</p>
        <p>Commentary quality is subjectively evaluated using a small, hand-built test suite<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/suites.py#L1">[19]</a>. The ChessCoachGui tool has a <strong>Suite</strong> button that generates five comments per test position<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/gui.py#L209">[20]</a>.</p>

        <h2 id="self-play">Self-play</h2>
        <p>ChessCoach self-play code began with the <a href="https://science.sciencemag.org/content/suppl/2018/12/05/362.6419.1140.DC1">AlphaZero pseudocode in Python</a>, using a popular Python chess library for position management. However, playing out games<a href="https://github.com/chrisbutner/ChessCoach/blob/9326d590d3917cbadf9b5881517c1ab66b1475e0/network.py">[1]</a> took on the order of minutes rather than seconds, so everything had to be ported to C++<a href="https://github.com/chrisbutner/ChessCoach/blob/27adabcb8f4612d0643a8eb8889035006c4dec72/cpp/ChessCoach/SelfPlay.cpp">[2]</a>.</p>
        <p>Many details are missed in the AlphaZero pseudocode. Because valuations are stored on child nodes rather than edges in a graph-theoretical sense, they need to be viewed from their parent's perspective for the purpose of move selection etc., so neural and terminal evaluations need to be flipped<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L735">[3]</a>. Consistent mapping between the (-1, 1) neural network value (tanh) range and [0, 1] probability domain is required<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Network.h#L74">[4]</a>. Dirichlet noise as a gamma distribution needs to be normalized to sum to 1.0 before mixing into the prior distribution<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L985">[5]</a>. The implementation of queen-knight and underpromotion policy plane mappings<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L62">[6]</a> is unspecified. Search tree reuse is not implemented<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1429">[7]</a>. Wording in the paper around temperature and sampling is ambiguous. Sampling during self-play is not <em>softmax sampling</em> as pseudocode names it<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1769">[8]</a>. Move diversity vs. Stockfish during tournament play is also underspecified, and missing from the pseudocode<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1782">[9]</a>.</p>
        <p>In ChessCoach, each self-play thread runs a loop<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1071">[10]</a> that waits for work, then plays games by alternating CPU and GPU work before finally saving and chunking the game data for training. The CPU piece uses a coroutine-like mechanism for each game in the batch, potentially looping over the full 800 simulations, but jumping out for each game as soon as a neural network prediction is required. The null/NaN/SelfPlayState returns to jump out<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1418">[11]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1537">[12]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L727">[13]</a> and SelfPlayState to resume<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1480">[14]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L628">[15]</a> may look messy, but I just hope that this system is clear in its intentions and behavior, and simple architecturally.</p>
        <p>For each tree search simulation, SBLE-PUCT<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1924">[16]</a> is used to select a <em>search path</em> down the tree<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1517">[17]</a> until reaching a terminal node or unexplored node, applying moves to a branched-off scratch game. The leaf node may be permanently or temporarily terminal<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L633">[18]</a>, or its evaluation may already be cached<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L709">[19]</a>. Otherwise, the input planes for the position need to be generated<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L726">[20]</a> and emplaced (directly constructed in place) in this game's slot<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1168">[21]</a>. For non-terminal leaves, after waiting for a network prediction if necessary, the node is expanded<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L754">[22]</a>, setting up child nodes with priors. When receiving a raw network prediction, logits are converted to a probability distribution via softmax<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L858">[23]</a>, then, if possible, the prediction is cached<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PredictionCache.cpp#L106">[24]</a>. Finally, regardless of category, the node's valuation and visit are backpropagated<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1563">[25]</a> up the search path, along with mate-proving.</p>
        <p>When initially expanding the root node before the first of 800 simulations, Dirichlet noise needs to be applied. However, because of tree reuse, the node may already be expanded. As an additional complication, if the new root was already in the reused tree, but was previously seen as a temporary draw via twofold repetition checking<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L847">[26]</a>, it may not be expanded. It can be hazardous trying to correctly add noise and perform related tasks because of these special cases. ChessCoach centralizes the logic<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1638">[27]</a> and calls into it as appropriate for self-play and tournament play.</p>
        <p>After simulations are finished, statistics are collected<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L887">[28]</a> and a move can be selected<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1740">[29]</a> and played in the real game. As in the AlphaZero paper, for the first 30 plies, moves are sampled in proportion to visit count, with each immediate child of the root having received some of the 800 visits. Sampling helps cover more of the potential <em>game space</em> of chess. After this, the <em>best move</em> is always selected. This is usually the most-visited move, as in the AlphaZero paper, but faster checkmates and slower opponent mates take priority<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2166">[30]</a>. Selecting the best move helps with game result attribution.</p>
        <p>In terms of data structures, the SelfPlayGame<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.h#L241">[31]</a> class extends the Game class and adds neural network input/output emplacement, statistics tracking and node management for tree reuse. The Node<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.h#L101">[32]</a> class builds a search tree through its <strong>children</strong> field. Nodes drive most of the memory consumption for self-play and tournament play, and are much more demanding than in classical engines, which can search deeply and then unwind. High-memory or extended-memory configurations are required on cloud platforms relative to CPU count. ChessCoach nodes were shrunk down from 64 to 48 bytes<a href="https://github.com/chrisbutner/ChessCoach/commit/82491110f968485c4aa977298deb0487539e5527">[33]</a>, expanded back to 64 bytes<a href="https://github.com/chrisbutner/ChessCoach/commit/f47756fa64aae1cc744c91bf9f9b5888069d8d58">[34]</a> with debug info and an unoptimized tablebase implementation, then shrunk to 32 bytes<a href="https://github.com/chrisbutner/ChessCoach/commit/3b485be354ffba88bb5dbf6d8baa40dba085f71b">[35]</a> with prior quantization (matching the prediction cache) and bit packing. Node size reduction helps tree search not just in memory envelope but also in search speed, through copying and locality improvements. Further improvements are possible; for example, minimizing memory consumption for leaf nodes, <a href="https://github.com/LeelaChessZero/lc0/issues/13">implemented by Lc0</a>.</p>
        <p>Child selection via PUCT is also an important optimization target that has received minimal attention<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1823">[36]</a> in ChessCoach. The <a href="https://github.com/dje-dev/Ceres#readme">Ceres project (Elliott, 2020)</a> pays particular attention to vectorizing PUCT calculations, and this type of work could help self-play and tournament throughput.</p>
        <p>Checking for draws by repetition is a notable detail that has spawned long-lived bugs and discussions in other projects. In chess, a draw by threefold repetition can be claimed by a player when the same position has been reached for the third time in a game, where the position includes the side to move and castling and en passant rights. Often when playing over the board, this type of draw needs to be actively claimed, but computer platforms usually rule the draw automatically, and this especially makes sense when no human players are involved.</p>
        <p>When an engine is searching, an optimization can be made. If a twofold repetition is encountered, this can be considered a draw early. If no other move is better than repeating, then the threefold repetition is inevitable with perfect play. However, this introduces a trap. Let's say that after playing a particular move, the resulting position would be losing but still the best option, so the engine enters the position. The opponent blunders and now a variety of drawing moves are possible. The engine thinks that returning to that previous position as a twofold repetition is just as good a draw as any other. However, it is not actually a draw yet in the real game. Now, the opponent has had more time to think and makes the winning move. Other variations are possible involving sub-optimal and then better play from the searching engine instead.</p>
        <p>To fix this problem, a change is necessary: only twofold repetitions with both parts encountered strictly <strong>after</strong> the search root can be considered a draw, since both were opted into rather than destined. Once the first instance is actually played on the board, the second instance is no longer considered a draw. ChessCoach implements this optimization safely by always treating twofold repetition as a temporary draw and re-checking each visit<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L677">[37]</a>. In contrast, threefold repetitions are cached and do not need to be checked again, even when the search tree is reused for future moves. Also, since ChessCoach has already generated legal moves, Stockfish draw-checking code is customized to omit this step<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L855">[38]</a>.</p>

        <h2 id="distributed-training-and-self-play">Distributed training and self-play</h2>
        <p>Generating 44 million AlphaZero-like self-play games requires mammoth computing resources. Even running non-stop for a year, a consumer GPU can only hope to generate 10-20 million.</p>
        <p>Through Google's TPU Research Cloud (TRC) I was able to access 4 v2-8 TPUs initially and approximately 50 v3-8 TPUs by the end of the project. Initially, I used Google Kubernetes Engine (GKE) to manage a small number of older-style TPUs with corresponding compute VMs. After this I was invited to an alpha of the newer-style <a href="https://cloud.google.com/blog/products/compute/introducing-cloud-tpu-vms">Cloud TPU VMs</a>, which do not require a separate compute VM. Performance is potentially much higher with code running locally. However, Kubernetes was not yet supported, so I set up custom automation via SSH session management.</p>
        <p>ChessCoach relies on simple building blocks for cluster-based training and self-play. Each machine runs the ChessCoachTrain binary and operates under the training (<em>train</em>) role and/or self-play (<em>play</em>) role<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L8">[1]</a>. At most one machine acts as a trainer. In smaller clusters the trainer also self-plays. Coordination is solely via Google Cloud Storage, under a gs:// bucket. The trainer looks for new data periodically and uses this to train the neural network and save checkpoints to storage. Self-play roles look for new checkpoints periodically and use these to self-play. Whenever a machine has saved 2000 games locally it chunks them and uploads the chunk to storage.</p>
        <p>Machines without the training role could pause whenever they know training has started and resume once they see the new checkpoint. However, this wastes time, as training data that is a little less fresh is usually better than nothing, and the window size of 1 million positions<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L139">[2]</a> smears this further. The exception is when using uniform predictions before the first checkpoint is available<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTrain/ChessCoachTrain.cpp#L320">[3]</a>. Machines could also clear any games in progress and start from scratch using new weights. However, because the N&nbsp;×&nbsp;M games in progress are overlapping randomly after a point, this effectively throws away (N&nbsp;×&nbsp;M)/2 full games. As more self-playing roles are added to the cluster, checkpoints arrive faster relative to the N&nbsp;×&nbsp;M and this wastage worsens. Instead, it is better to just continue the existing games using the new network<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L277">[4]</a> in Python, again favoring bulk volume. C++ code remains mostly unaware of the changeover, but does get signaled to clear the prediction cache<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1095">[5]</a>.</p>
        <p>Machines without the self-play role<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/train.dockerfile#L10">[6]</a> wait until enough data is available<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTrain/ChessCoachTrain.cpp#L183">[7]</a> before training the next checkpoint: they do not try to self-play. This is important for large clusters because training may be happening so often that self-play games that started many checkpoints ago on the training role are still trying to finish. I am not confident of the cut-off point, but it is probably safe for the trainer to also self-play with 25 or fewer v3-8 TPUs, using the default schedule.</p>
        <p>Older-style TPUs are managed via GKE using cluster-*.sh scripts and cluster-*.yaml deployment specifications. A service account is set up using cluster-prep-creds.sh<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cluster/cluster-prep-creds.sh">[8]</a> as a TPU Admin and Storage Admin, and a key.json is generated and downloaded to the project root. The script docker-build-upload.sh<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/docker-build-upload.sh">[9]</a> is used to build a docker image and upload it to the Google Container Registry (GCR). The files cluster-train-deployment.yaml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cluster/cluster-train-deployment.yaml">[10]</a> and cluster-play-deployment.yaml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cluster/cluster-play-deployment.yaml">[11]</a> are updated to reference the latest docker image. The script cluster-up.sh<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cluster/cluster-up.sh">[12]</a> sets up the cluster, by default using preemptible n2-highmem-4 VMs for the TPUs, and including a single n1-standard-1 VM in a critical node pool for DNS<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cluster/cluster-common.sh#L15">[13]</a>. The script cluster-run.sh<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cluster/cluster-run.sh">[14]</a> <em>applies</em> the deployment specifications, creating or updating deployments as necessary using a <em>Recreate</em> strategy to match the latest details.</p>
        <p>Newer-style Cloud TPU VMs, including pods, are managed using the alpha.py<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/alpha.py#L505">[15]</a> script, which runs in what-if mode until the <code>--confirm</code> flag is passed. The service account and key.json are set up as before (the same ones can be reused) and docker-build-upload.sh is run as before. Quota information (extrinsically or intrinsically imposed) and docker run commands are updated at the top of alpha.py. Command-line arguments drive the top-level command used and the TPUs and deployments managed. At the time of writing, special care is needed to run inside docker on a Cloud TPU VM<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/alpha.py#L55">[16]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/train.dockerfile#L18">[17]</a>. Docker needs to run privileged, or the /dev/accel* devices need to be mounted; /lib/libtpu.so needs to be mounted; /usr/share/tpu needs to be mounted; and <strong>wheel</strong> and /usr/share/tpu/tf_nightly*.whl need to be installed in the docker CMD before the intended entry point. In future, Cloud TPU VMs will use versioned TensorFlow releases, and this installation can be cached in the docker image. Additionally, private binaries are currently required to support TensorFlow Text and other libraries with custom ops, although I do not expect this to be the case for long. The script alpha.py is minimum-effort and is resilient to SSH disconnects and ChessCoach/TensorFlow crashes, but fragile to harder hangs or TPUs being pulled away. It continuously pipes the output of each remote container to a file like AlphaManager/20210712-210214/alpha-1.log in local ChessCoach storage.</p>

        <h2 id="tournament-play">Tournament play</h2>
        <p>For tournament play, ChessCoach implements the <a href="https://www.shredderchess.com/download/div/uci.zip">Universal Chess Interface (UCI)</a>, a text-based protocol operating through standard input and output streams. The protocol is partially stateless in that position and time control information is always given in its entirety. It is partially stateful in using the previous position specification for searches and implicitly reusing search state between moves for what is loosely the same game. It is important to always process standard input commands, even while searching.</p>
        <p>Through UCI, ChessCoach can be instructed to search a position infinitely<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachUci/ChessCoachUci.cpp#L496">[1]</a>; to search until some condition is met based on nodes/mate/time; or to search using as much time as it chooses, given some kind of time control for the match. Time control is specified as overall search time per player for the game; additional search time per move; and in another mode, the number of moves for which the original time control repeats<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachUci/ChessCoachUci.cpp#L532">[2]</a>. For the most part, ChessCoach emulates AlphaZero's trivial time control strategy and for each move searches for 1/32nd of the total remaining time<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2688">[3]</a>.</p>
        <p>When searching a position, ChessCoach first tries to reuse the existing search tree and prediction cache<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2432">[4]</a>, pruning<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L918">[5]</a> down the tree following any additional moves applied. The N&nbsp;×&nbsp;M virtual games become <em>shadows</em> sharing a single search tree<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2826">[6]</a>. The WorkerGroup<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/WorkerGroup.h#L25">[7]</a> class is used to set up the search threads initially<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2251">[8]</a>, and the WorkCoordinator<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Threading.cpp#L106">[9]</a> class helps with starting, stopping and waiting for multi-threaded tasks like UCI searches. The job of the search threads is to collaboratively build out a search tree such that the best move at the root finishes with the most visits<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2471">[10]</a>. One of the worker threads is called the <em>primary</em> and does additional housekeeping<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2280">[11]</a> such as checking time control, printing the principal variation, updating the debug GUI when enabled, reporting the best move, and cleaning up.</p>
        <p>Threads safely work on the same search tree by using std::atomic* fields<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.h#L150">[12]</a>. A good example is when contributing a valuation to a node when backpropagating, using an exponentially weighted moving average (EWMA)<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L256">[13]</a>. EWMA helps the search adapt more quickly when making new tactical discoveries, but care is needed to avoid oscillations and excessive forgetfulness. The backpropagation weight involves a simple atomic increment. The calculation of the average is more complex, so a compare-and-swap instruction is attempted until it succeeds. If another thread swoops in and updates the value first, the calculation needs to be rebased before it is reattempted. In both cases, std::memory_order_relaxed is used because there is no need for ordering guarantees between either of these fields and any other field.</p>
        <p>The use of different atomic primitives is situational: fetch_add, fetch_sub, compare_exchange_weak, compare_exchange_strong and exchange are spread throughout SelfPlay.cpp. Acquire/release semantics are only required when one field acts as a ready signal for another payload field. The two specific situations are (a) SearchState::principalVariationChanged<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.h#L343">[14]</a> signaling Node::bestMove, and (b) Node::expansion signaling Node::children. However, acquire/release is mostly automatic for x64 and more important for ARM, which is not a target platform currently.</p>
        <p>Only one thread is allowed to expand any particular node, by first getting a neural network evaluation, then allocating memory for the node's children and setting them up with priors. Because this is expensive and involves allocation, it is better to treat this like a lock rather than letting threads destructively race and cleaning up the fallout. Threads use compare-and-swap instructions on the Node::expansion field when attempting to claim ownership. If a thread has already committed to a node for a particular simulation and loses this race, the simulation just gives up for the current round of CPU work. This is called a <em>failed node</em>, visible with the <code>debug on</code> UCI command. However, if the thread is still selecting children and can see in advance that another thread holds expansion permission for a particular child, it treats that child as <em>blocked</em>, and another is selected. If a blocked child was going to be best, then backpropagation weight is cleared, breaking the chain upwards. This helps prevent flooding problems in small sub-trees during multi-threaded search.</p>
        <p>Information freshness is important for tournament play, increasing the effective &quot;sequentiality&quot; of PUCT search. With parallel shadows sharing a tree, instead of running each simulation as an isolated coroutine, it helps to let them all &quot;cash in&quot; their results<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2373">[15]</a> after a network prediction before letting them all choose new search paths.</p>
        <p>While the search tree is still small, only one thread is allowed to work, with limited parallelism<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2385">[16]</a>. This is called <em>slowstart</em> and prevents too many simulations from flooding in until decision metrics can be calculated more accurately, and until sub-optimal choices via virtual exploration and loss are more viable. The feature most visibly helps with Strategy Test Suite (STS) scores for short, 200 millisecond searches, but likely helps in bullet time controls and in setting up longer searches.</p>

        <h2 id="tournament-play-techniques">Tournament play techniques</h2>
        <p>A variety of techniques help improve tournament strength.</p>
        <p>When making AZ-PUCT and SBLE-PUCT calculations for all children of a parent, a PuctContext<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1823">[1]</a> is first constructed to pre-compute common terms. A selection algorithm like introselect<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1876">[2]</a> is used to eliminate linear exploration candidates after calculating the appropriate cut-off<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1849">[3]</a>, based on search progress and sub-tree node count relative to the root.</p>
        <p>Mate-proving propagates forced wins and losses up the search tree<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2019">[4]</a>, adding certainty to value<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L245">[5]</a> for child selection during tree search, and adding certainty to move selection<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2194">[6]</a> when making a decision. If a choice of moves is available and one of them leads to a guaranteed win, then that move can be played, and the opponent's move leading to this position is a guaranteed loss. If all move choices lead to a guaranteed loss, then one of them must be played and the opponent's move leading to this position is a guaranteed win. Classical engines usually generalize this concept, using exact, upper and lower bounds in conjunction with alpha-beta pruning and adding in draw propagation and endgame tablebase bounding. ChessCoach's implementation is special-cased and primitive by comparison.</p>
        <p>Faster mate incentives are layered on top of mate-proving and encourage more visits to faster mates<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L124">[7]</a>. Helping known wins compete with other exploration incentives encourages tree shape to better match move quality and helps valuation above the proof to better reflect prospects below. Additionally, an engine's mate-in-5 is not necessarily exact but means mate in <strong>at most</strong> 5 moves. Encouraging visits to more promising mates helps to refine the valuation of the best possible move.</p>
        <p>While slower mate disincentives are not necessary to differentiate guaranteed losses, because the search already scrambles for value in losing situations, it does help to clear exploration incentives for known losses by clearing priors<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L308">[8]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L371">[9]</a>. This reduces value dilution when a tactical surprise runs counter to the engine's expectations from training.</p>
        <p>First-play urgency (FPU) describes the value estimate of nodes that have never been visited. While increasing this parameter can correspondingly increase search breadth, this is less effective further from the root because child selection decisions are made hierarchically. FPU is never relevant for a child if its parent is never visited. So, rather than driving some kind of global depth vs. breadth, FPU reflects confidence in training and drives dawdling vs. focusing surrounding the principal variation. AlphaZero made an initially astonishing decision in setting this to zero, often giving each first-visited child many more visits before considering an alternative. However, this becomes increasingly viable as training quality improves and achieves more depth in a more intuitive type of search.</p>
        <p>ChessCoach sets FPU to a win at the root only<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L793">[10]</a>. This ensures that every move is least considered; for example, a mate-in-one would not be missed. While this would often happen quickly anyway during tournament play, root-win-FPU also helps reduce the sharpness of policy training targets in self-play data, which can hurt the feedback cycle. AlphaZero benefited from smoothing when making 8 simulations in parallel during self-play, and other projects have applied temperature of 1.03 at the root to a similar end.</p>
        <p>In a more complex technique, when encountering a guaranteed draw during search, ChessCoach sets the FPU of unvisited siblings of the draw to the current root valuation, flipped to the correct perspective<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1998">[11]</a>. The initial visit is also forgiven rather than backpropagated further. This helps avoid value dilution in positions where one player is clearly winning, but many draws by repetition are possible; for example, in an open position with queens. Such draws are too difficult for the neural network to predict, so their priors are too high, and it usually takes many visits to the draws until exploration incentives for alternative moves increase sufficiently. Wins and losses do not carry this same danger, as they are correctly incentivized vs. the default zero FPU of siblings. Draw-sibling-FPU recognizes that when a position is winning, non-drawing moves are usually better than drawing moves and are worth considering immediately. This technique especially helps with many simulations flooding into small sub-trees.</p>
        <p>More general, explicit flood-prevention across the search tree, in a manner akin to expansion-blocking, did not improve strength. This may be because of the existing effectiveness of slowstart, loss-prior-clearing and draw-sibling-FPU against flooding. However, classification and tuning for this topic is sensitive and difficult, and I am sure that effective techniques and improvements could be dropped in.</p>
        <p>Endgame tablebases allow for perfect play when at most 6 or 7 pieces including pawns and kings remain on the board. Checkmates and draws are proved backwards from the end of all possible games with this many pieces or fewer, and the results are compressed (although the storage requirements for 7-piece tables are extreme). Syzygy is a tablebase format that focuses on distance-to-zero (DTZ) rather than distance-to-mate (DTM), which gives knowledge of <em>cursed wins</em> and <em>blessed losses</em> that are ruined or saved by the 50-move rule. However, this can result in a slower and more unnatural path to victory. ChessCoach uses a modified version of Stockfish's Syzygy probing code<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Syzygy.h#L20">[12]</a>, <a href="https://github.com/official-stockfish/Stockfish/commit/7caa6cd3383cf90189a1947c9bdf9c6fea1172a6">contributed to Stockfish by de Man (2013)</a>, during tournament play. Syzygy compression is much higher than that of previous tablebase formats, at the expense of increased probing complexity.</p>
        <p>There are two different ways in which Syzygy probing is used. When the root position to be searched has sufficiently few pieces and lies within the tablebase, root probing<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Syzygy.cpp#L46">[13]</a> is performed, which perfectly categorizes each move into wins, cursed wins, draws, blessed losses and losses. These categories take highest priority<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2186">[14]</a> during final move selection. However, the search is still performed in order to differentiate within these categories. Since no distance-to-mate is available it can help to prove this during the search.</p>
        <p>When the root position is not in the tablebase, positions in the tree may still be after captures. When meeting some additional conditions, positions are win/draw/loss (WDL)-probed<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Syzygy.cpp#L216">[15]</a> and given a bounded value. ChessCoach treats this as another special case of the generalized bounding of classical engines and adjusts any value backpropagating through the node to this bound. Both types of probing are reported to the UCI protocol as <em>tbhits</em><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2802">[16]</a>.</p>
        <p>Neural network-based engines have a difficult time making progress in endgames because they blend in overly optimistic valuations for unresolved positions at shallow search depths. Looking further down lines, these engines see more concrete outcomes that are valued more realistically, and thus prefer to shuffle pieces around and stay in their &quot;optimistic bubble&quot;. This is often dangerous because it can allow the opponent's king to come into play, or result in a draw by the 50-move rule in an otherwise winning position. By contrast, classical engines only look at maximum depth valuations, and often use heuristics to adjust valuations according to specific material combinations in endgames (for example, labeling opposite colored bishops as drawish) or as a 50-move draw is approached.</p>
        <p>ChessCoach takes more of classical approach in endgames in order to make progress towards a win, by using minimax to choose a move<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1812">[17]</a>. After PUCT search has completed, the best line is chosen<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1681">[18]</a> according to leaf valuation, rather than considering visits driven by average valuations. Thresholds<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L209">[19]</a> determine when sufficient visits have been made to trust sub-tree valuations. In general, valuations are also scaled towards a draw as a 50-move draw approaches<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1560">[20]</a>, less so in the middlegame and more so in the endgame. Valuation scaling risks optimistic shuffling in the search tree, reducing depth, but it may be better to do this here than over the board.</p>
        <p>It makes intuitive sense in endgames to also use minimax to drive the search. However, a naïve approach does much more harm than good. It is possible that a comprehensive implementation such as that used in the <a href="https://github.com/manyoso/allie#readme">Allie engine (Treat, 2019)</a> improves overall strength in ChessCoach. Engines such as KataGo and Lc0 have also blended utility scores such as game score in Go, or estimated moves remaining in chess, into position valuation in order to incentivize progress, and this could also be of benefit for ChessCoach.</p>
        <p>AlphaZero found that when opponents used an opening book that encouraged draws, introducing intentional move diversity dramatically increased win rate, at the expense of some losses. With admittedly low statistical significance, applying this technique generally to ChessCoach<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1789">[21]</a> did improve win rate. However, sampling temperature was necessarily much lower because of linear exploration. The value delta threshold was also reduced, and fewer opening moves were diversified<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L203">[22]</a>. Caution is required with parameterization. Move diversity based on a value threshold becomes more dangerous as exploration is decreased, as PUCT is happier to leave runner-up moves close in value but under-exploited, potentially missing tactical traps and other downsides.</p>
        <p>Tournament play is equivalently referred to as <em>search</em>, <em>UCI</em> and <em>TryHard</em> in code and comments, as distinct from self-play.</p>

        <h2 id="configuration-management">Configuration management</h2>
        <p>Configuration is defined in config.toml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml">[1]</a>. Unfortunately, it is parsed both by the toml11 library in C++ and the toml library in Python. Config.cpp<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Config.cpp">[2]</a> and config.py<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/config.py">[3]</a> expose configuration to other code.</p>
        <p>Configuration in C++ is designed to allow fast access during self-play and tournament play. Whenever a keyed lookup or update is performed, the parse is repeated using an appropriate policy<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Config.cpp#L138">[4]</a>.</p>
        <p>Multiple networks can be defined in config.toml and override base training and self-play configuration. At the top level, the network to use is specified by name, and the role or roles are chosen. Miscellaneous configuration is defined at the bottom.</p>
        <p>UCI options are defined in config.toml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L311">[5]</a> and automatically override configuration items with the same name<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachUci/ChessCoachUci.cpp#L353">[6]</a> when set, but only in C++. Manual propagation to Python is required, and this is done for <strong>network_weights</strong><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachUci/ChessCoachUci.cpp#L405">[7]</a>. Name matching is also used to get existing values when listing options<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachUci/ChessCoachUci.cpp#L231">[8]</a>.</p>
        <p>During EPD-based parameter optimization, parameters defined in config.toml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L300">[9]</a> again automatically override configuration items with the same name<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L250">[10]</a> in C++ only.</p>
        <p>During tournament-based parameter optimization, the parameters defined in config.toml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L300">[9]</a> are instead applied through the UCI option interface<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachUci/ChessCoachUci.cpp#L353">[6]</a> in a separate ChessCoachUci process via cutechess-cli.</p>
        <p>The path to Syzygy endgame tablebases stored in config.toml is treated as a special case and rooted to the data root. At startup, ChessCoach checks whether these files need to be copied from cloud storage to local storage<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/config.py#L99">[11]</a>.</p>

        <h2 id="prediction-cache-transposition-table">Prediction cache, transposition table</h2>
        <p>The prediction cache stores recent neural network predictions in the form of a multi-threaded key/value store. When encountering a position that is already in the cache, tree search can immediately complete the current simulation and move on to another one rather than waiting<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1545">[1]</a>.</p>
        <p>During self-play, the prediction cache key is Stockfish's Zobrist hash<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.cpp#L771">[2]</a> and a representation of whether the position has repeated, for the current position and the last 7 positions<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L345">[3]</a>, matching the history planes that would otherwise be used to make a neural network prediction<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L379">[4]</a>. The no-progress count for the 50-move rule is also mixed in.</p>
        <p>During tournament play, the cache is used as a transposition table, so the key is just the current position's hash, a representation of whether the position has repeated, and a bucketed version of the no-progress count<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L339">[5]</a>.</p>
        <p>With default settings, the cache is sized at 8 GiB with 8 1-GiB tables. Tables are filled with 1024-KiB chunks, each containing 8 cache entries<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PredictionCache.h#L27">[6]</a>. A cache entry holds the key and the neural network's value and policy prediction. The policy is quantized<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Network.h#L62">[7]</a> from 32-bit floating point to 16-bit integer format and even then can only fit data for 56 moves: positions with more moves do not use the cache. An <strong>age</strong> field also helps preserve the most recently used entries when evicting to make room for a new entry<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PredictionCache.cpp#L111">[8]</a>. The tables are allocated using large pages<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PoolAllocator.cpp#L31">[9]</a> when available, to help with performance. Large pages require locking permission and special initialization<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PoolAllocator.cpp#L65">[10]</a> on Windows.</p>
        <p>Because the cache is read and written to by multiple threads without locks, data validation<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PredictionCache.cpp#L88">[11]</a> is used to protect against type-1 errors (key collisions), type-2 errors (index collisions) and spliced data. When extracting a policy from the cache, the probabilities are summed and rejected if the sum is not close to 1.0.</p>

        <h2 id="data-pipelines-and-storage">Data pipelines and storage</h2>
        <p>During self-play and tournament play, the Game class generates input planes<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L372">[1]</a>, and these are used immediately for neural network predictions. Training data requires input planes, policy output planes, value outputs, and MCTS value outputs. However, this training data is often at rest, so it makes sense to compress it.</p>
        <p>Each prediction requires 109 input planes: 13 piece and repetition planes for the current position and each of the last 7 positions, plus 5 auxiliary planes for castling rights and the 50-move rule. The piece and repetition planes overlap heavily though, because of the history aspect, so each new position only introduces 18 new planes: the 13 fresh piece and repetition planes plus the 5 fresh auxiliary planes. By only including the fresh data for each position, using 8 bytes per packed plane, input planes can be reduced from 872 bytes to 144 bytes.</p>
        <p>Policy output planes are stored as training targets and require 73 planes per position. These include arbitrary float logits and cannot be packed, instead taking up 256 bytes per plane for a total of 18,688 bytes uncompressed. However, most of the 4,672 conceivable moves are not legal in a given position, so assuming an average of 35 legal moves, these sparse planes can be compressed to 280 bytes plus overhead using a scatter/gather scheme with 4-byte indices and 4-byte values.</p>
        <p>The value target is just the perspective-flipped game result and can be compressed from 4 bytes per position to 4 bytes per game. The MCTS value target does not offer trivial compression opportunities. In total, for a game with 135 positions and 35 legal moves per position, training data can be compressed from 19,568 bytes to approximately 428 bytes of payload. This scales to 105.7 TiB vs. 2.3 TiB of payload for 44 million games, again estimating 135 positions and 35 legal moves. Further compression is possible using ZLIB.</p>
        <p>The Game class implements compressed and uncompressed generation of input and output planes in C++<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.h#L186">[2]</a>. While planes are usually decompressed in the data pipeline in Python, the Game class also decompresses policy planes to support the ChessCoachGui tool and generates uncompressed policy planes for test purposes. A variety of move inferences and guesses<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.h#L179">[3]</a> also support the ChessCoachGui tool.</p>
        <p>ChessCoach's data pipeline feeds neural network training and is implemented in Python using tf.data. This API offers Datasets, which operate in <em>graph mode</em> using TensorFlow ops rather than Python code. Because of this, they can be a little picky loading data and prefer tf.train.Example records in TFRecord format. TFRecord<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.cpp#L452">[4]</a> files consist of a sequence of records, each with a length, payload, and checksums. In this case, the payloads are protobufs matching the tf.train.Example<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/protobuf/ChessCoach.proto#L74">[5]</a> specification, consisting of tf.train.Features with differently typed lists.</p>
        <p>Unfortunately, using the TensorFlow API to write these records from Python is too slow to be viable; therefore, ChessCoach reads and writes TFRecords from C++ 100 to 1,000 times as fast. The protoc utility<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/scripts/protoc.sh">[6]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/scripts/protoc.cmd">[7]</a> is used to generate code for ChessCoach.proto, which implements the tf.train.Example specification. The protobuf library is linked statically to avoid conflicting with the copy that TensorFlow links dynamically. The Storage class implements serialization<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.cpp#L385">[8]</a> and disk streaming<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.cpp#L469">[9]</a>. Each game is written as a single tf.train.Example in a single TFRecord, using zlib compression, and chunks of 2,000 games are just decompressed, concatenated and re-compressed<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.cpp#L142">[10]</a>.</p>
        <p>Commentary is also saved in this format<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.cpp#L561">[11]</a>, although because variations are branching rather than linear, and not every position has a comment, input planes cannot be compressed. A CommentarySaveContext<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.h#L50">[12]</a> class is used to implement a training/validation split at 95%/5%<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachPgnToGames/ChessCoachPgnToGames.cpp#L97">[13]</a>. Preprocessing is also performed<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Preprocessing.cpp#L35">[14]</a> to eliminate most non-English comments and improve quality.</p>
        <p>One key detail with input planes is that early positions in a game do not have 7 previous positions for history planes. Lc0 found that synthesizing data rather than zeroing the planes gave the network a more consistent distribution to operate with, and this technique helped ChessCoach slightly. When too little history is available, the earliest position is <em>saturated</em> backwards, flipping perspective between moves, using the HistoryWalker<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L641">[15]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Game.cpp#L383">[16]</a> utility.</p>
        <p>After the primary model's compressed data has been loaded by the data pipeline, it needs to be decompressed using the TensorFlow API. Input planes are reconstructed by mapping over slices of the game's compressed input planes tensor<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L81">[17]</a>. This again requires synthesis of history via saturation for early positions, but with a simpler implementation because all training games begin from the starting position. Policy outputs are decompressed by constructing ragged tensors from the indices and values, and then scattering them<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L108">[18]</a>. Game results are just stretched out with alternating flips<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L78">[19]</a>.</p>
        <p>Shuffling training examples over a 1 million sized window adds challenge. Most data read is discarded<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L182">[20]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L164">[21]</a> as a time/space trade-off. A large shuffle buffer is used on Cloud TPU VMs, although this probably needs to be slightly reduced on older-style TPUs, and heavily reduced on consumer desktops. Memory consumption is high because decompressed examples are stored in the buffer. A scheme for storing position pointers for post-shuffle decompression may be possible in some way. However, by targeting low correlation you are effectively wanting one position per game, so a pointer to the whole thing seems to end up worse. TensorBoard data over generations of ChessCoach training runs does justify the high window size requirement.</p>
        <p>Training data in the same TFRecord format is also generated using the ChessCoachPgnToGames tool over the <a href="https://lczero.org/blog/2018/09/a-standard-dataset/"><em>CCRL Dataset</em> published by Lc0 (2018)</a>, based on <a href="https://ccrl.chessdom.com/ccrl/4040/about.html">Computer Chess Ratings Lists (CCRL)</a> data. PGN parsing is implemented in Pgn.cpp<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Pgn.cpp#L47">[22]</a>. The validation portion is used as described in <a href="#neural-network-training">Neural network training</a>. The training portion of the dataset can be used for supervised training<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L94">[23]</a>, rather than using self-play data. This results in a network with an estimated 2650 Elo rating; however, the network ends up with huge gaps in its knowledge. Because it never sees something like a Qxh7# mate-in-one or large mid-game material imbalances in the data, it emulates high-level play and makes threats, but does not necessarily follow through when allowed. Equivalently, its search tree does not necessarily see opponents following through, and with AZ-PUCT it gets checkmated easily.</p>

        <h2 id="cpp-and-python-interoperation">C++ and Python interoperation</h2>
        <p>Python is most commonly run using the CPython reference implementation, whose straightforward C interoperability has contributed to Python's success. CPython supports C/C++ hosting Python code and Python hosting C/C++ code, in a macro sense and in callback form.</p>
        <p>In ChessCoach, C++/Python interoperation always begins with a C++ binary for consistent initialization. C++ calls in to Python via the PythonNetwork<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonNetwork.h#L61">[1]</a> class, and in some scenarios, Python calls in to C++ via the PythonModule<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.h#L26">[2]</a> class, after an <strong>import chesscoach</strong> statement.</p>
        <p>Initialization has some quirks, especially on Windows, and is handled in the ChessCoach<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/ChessCoach.cpp#L82">[3]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/ChessCoach.cpp#L157">[4]</a> class.</p>
        <p>It is necessary to hold the global interpreter lock (GIL) when calling in to Python code, and it can help performance to give it up while in C++ code. PythonContext<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonNetwork.h#L36">[5]</a> and NonPythonContext classes are used for convenient GIL management.</p>
        <p>Numpy multi-dimensional arrays are usually used to marshal data across the API boundary. NO_IMPORT_ARRAY is defined to include numpy in multiple translation units<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonNetwork.h#L34">[6]</a> (.cpp files), but undefined in ChessCoach.cpp<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/ChessCoach.cpp#L30">[7]</a>.</p>
        <p>When returning TensorFlow data to C++, the <a href="https://github.com/tensorflow/tensorflow/blob/a4dfb8d1a71385bd6d122e4f27f86dcebb96712d/tensorflow/python/framework/ops.py#L1073">np.array(memoryview(X))</a> construct is used to avoid an additional copy after readback.</p>

        <h2 id="debug-gui">Debug GUI</h2>
        <p>The debug GUI is a web page using chessboardjs, hosted locally in Python with WebSockets for callbacks, and launched via the ChessCoachGui and ChessCoachUci C++ binaries. The GUI operates in <em>pull</em> and <em>push</em> modes<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/gui.py#L103">[1]</a>, with pull via ChessCoachGui, allowing the user to browse training data, and push during UCI search, updating on the configured interval<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L239">[2]</a>.</p>
        <p>The GUI itself is quite trivial: it shows a data table and a chess board. The board highlights moves based on the posterior probability distribution after tree search<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/js/gui.js#L27">[3]</a>. In push/UCI mode, dragging the slider moves the data/highlighting through the history of the search, and clicking on moves drills into search lines<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/js/gui.js#L101">[4]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L196">[5]</a>.</p>

        <h2 id="portability">Portability</h2>
        <p>One of the original goals of the project was to be able to viably train and run ChessCoach on a desktop machine with a single GPU. While I was not able to achieve this, I did focus on supporting ChessCoach on a single machine and cluster; local and cloud storage; single-GPU, multi-GPU and TPU; and Linux and Windows.</p>
        <p>Single machine and cluster equivalence is implemented by allowing machines to operate using <em>train</em>, <em>play</em> or <em>train|play</em> roles<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L8">[1]</a>. Training and self-play roles do not care whether their storage is local or cloud-hosted and check periodically for updates in either case when they are up in top-level training stage management code<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTrain/ChessCoachTrain.cpp#L204">[2]</a>.</p>
        <p>Local and cloud storage are treated equally using the tf.io.gfile abstraction in Python and by deciding on a <em>data root</em> at startup time<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/config.py#L76">[3]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/config.py#L101">[4]</a>. All relative dynamic storage paths are rooted to the data root. Because all cloud storage access is via Python, C++ code sometimes needs to call in awkwardly<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L603">[5]</a>. C++ and Python can also choose to use local storage explicitly<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/config.py#L140">[6]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Storage.cpp#L509">[7]</a>, even in parallel; for example, for game data before chunking, and parameter optimization results.</p>
        <p>ChessCoach enters <em>TPU mode</em> when it can successfully initialize a TPUStrategy at startup<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L92">[8]</a>, either for newer-style Cloud TPU VMs, or failing that, older-style TPUs. This determines whether TensorFlow's listing of logical TPU devices or logical GPU devices is used. In TPU mode, the TPUStrategy is used for training; otherwise, when there is more than one GPU available, a MirroredStrategy is used for training<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L94">[9]</a>; otherwise, the default strategy is used for training. In any case, distributed strategies are not used for inference; instead, the relevant logical devices are used as tf.device contexts<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/network.py#L536">[10]</a>. Although distributed strategies abstract away many differences, the training schedule still needs to be adjusted. The per-replica batch size in config.toml<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L140">[11]</a> is multiplied by the device count to give the global batch size<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L86">[12]</a>, and this is used to initialize data pipelines<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/dataset.py#L244">[13]</a>. Model.fit() needs to know how many global batches to run, so various step intervals are divided by the device count<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L159">[14]</a>. Learning rate schedules also need to think globally<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/training.py#L270">[15]</a>. Commentary training scales similarly to the primary model; however, only the primary model multiplies the learning rate by the device count.</p>
        <p>Cross-platform C++17 facilities were used where available, but some platform-specific code is abstracted via the Platform<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Platform.h#L39">[16]</a> class, and branched via the CHESSCOACH_WINDOWS<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Platform.h#L25">[17]</a> definition in a few cases. <a href="#build">Build infrastructure</a> supports Linux and Windows.</p>

        <h2 id="strength-testing">Strength testing</h2>
        <p>Suites of test positions have been used for decades by human players and more recently, for chess engine development. <em>Win at Chess</em> (WAC) (Reinfeld, 1958) is a famous example. The Chess Programming Wiki maintains an <a href="https://www.chessprogramming.org/Test-Positions">extensive list</a>.</p>
        <p>Test suites are often used to validate the behavior of chess engines and to improve their play through tuning of search logic, static evaluation functions, and parameters for pruning and optimization techniques.</p>
        <p>ChessCoach uses two main test suites: the Strategic Test Suite (STS) (<a href="https://sites.google.com/site/strategictestsuite/">Corbit &amp; Swaminathan, 2008-2014</a>; and <a href="http://www.talkchess.com/forum3/viewtopic.php?t=56435">Mosca, 2015</a>) for positional evaluation and holistic strength estimation, and the <a href="http://talkchess.com/forum3/viewtopic.php?t=71045">Arasan21 suite (Dart, 2019)</a> for tactical evaluation. These suites use the Extended Position Description (EPD) format, which is somewhat like Forsyth–Edwards Notation (FEN) but expandable with operations and comments. EPD parsing is implemented in Epd.cpp<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Epd.cpp#L38">[1]</a>.</p>
        <p>STS<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/StrengthTests/STS.epd">[2]</a> consists of 1,500 positions in 10 categories with points offered for the best four moves in each position; for example, 10, 3, 3 and 2 for the first position. The final score out of 15,000 can be passed through a linear function<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachStrengthTest/ChessCoachStrengthTest.cpp#L159">[3]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L1273">[4]</a> to estimate Elo rating, based on logic in the <a href="https://github.com/fsmosca/STS-Rating/blob/master/sts_rating.py">STS-Rating tool (Mosca, 2019)</a>. This estimation is surprisingly accurate relative to other test suites and methods, perhaps because other suites often assign a single best move and have a more narrow, tactical focus. Each position is searched for 200 milliseconds, for a total of 5 minutes overall.</p>
        <p>The Arasan21 suite<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/StrengthTests/Arasan21.epd">[5]</a> consists of 199 positions with difficult tactical problems that usually take multiple seconds of search time for even the best engines to solve. Some positions specify a move to avoid rather than a best move. ChessCoach calculates a score out of 199 points using 10 seconds of search time per position, for a total of approximately 33 minutes overall.</p>
        <p>As mentioned in <a href="#neural-network-training">Neural network training</a>, STS is run during training.</p>
        <p>Standalone testing of any EPD suite can be run using the ChessCoachStrengthTest<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachStrengthTest/ChessCoachStrengthTest.cpp#L46">[6]</a> tool. This tests ChessCoach slightly more efficiently than using external tools, and extracts some additional metrics. However, it is equally possible to run external tools in conjunction with the ChessCoachUci interface.</p>

        <h2 id="parameter-optimization">Parameter optimization</h2>
        <p>In ChessCoach, parameter optimization is the process of tuning a variety of parameters that affect playing strength, to find a global optimum via Bayesian optimization. In a machine learning context, this is called <em>hyperparameter optimization</em> because network weights are themselves parameters, and it aims to improve training speed and effectiveness.</p>
        <p>Generally, optimization evaluates the domain effectiveness of various combinations of parameters, outputting either the best combination found, or the expected best combination via modeling. Various strategies are used for data acquisition, deciding on parameter combinations to try by using simple ideas such as <em>grid search</em> and <em>random search</em>, and more complex strategies involving exploration/exploitation trade-offs.</p>
        <p>Bayesian optimization usually uses Gaussian Processes over the multivariate parameter space to predict global optima and construct acquisition functions for further evaluations. ChessCoach uses the <a href="https://scikit-optimize.github.io/stable/">Scikit-Optimize (skopt)</a> implementation with the <em>Expected Improvement</em> (EI) acquisition function<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L50">[1]</a>. More advanced techniques are possible, and this configuration underweighted exploration, especially when distributions were noisy or skewed. However, it was the most stable and deterministic in getting to results.</p>
        <p>ChessCoach has two optimization modes<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L121">[2]</a>. The first is EPD mode, which runs test suites such as Arasan21 and uses a <em>nodes required</em> metric. The second is tournament mode, which runs mini-tournaments against a baseline player such as ChessCoach with default parameters, or Stockfish, and uses a relative Elo metric. Both metrics are normalized; however, <em>nodes required</em> can form a very one-sided distribution, which can confuse modeling. In contrast, Elo is quite well behaved as long as enough games are run per mini-tournament.</p>
        <p>In EPD mode, the <em>nodes required</em><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L286">[3]</a> metric represents the number of simulations required to find the best move in each position without switching away from it. If the best move is not found, a <em>failure nodes</em> value is returned instead, and this can be tuned to favor absolute correctness vs. solution speed.</p>
        <p>In tournament mode, the time control<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L298">[4]</a> can be varied to favor shorter or longer games. Some parameters are only meaningful with sufficient search time. However, using longer games for optimization can be very expensive computationally. Even with distributed community resources available, Fishtest uses only 60+0.6 time control. ChessCoach uses <a href="https://github.com/cutechess/cutechess#readme">cutechess-cli (Pihlajisto &amp; Jonsson)</a> to run tournaments<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L238">[5]</a> and <a href="https://www.remi-coulom.fr/Bayesian-Elo/">bayeselo (Coulom)</a> to calculate relative Elo<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L273">[6]</a>. An extremely hastily built, distributed sub-mode is possible, spreading over a cluster in order to play out mini-tournaments more quickly. While the initial focus is on evaluation turnaround time<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L61">[7]</a>, with enough machines available, multiple evaluations can be made in parallel<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L336">[8]</a>. Distributed optimization relies on the uci_proxy_server.py<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/uci_proxy_server.py">[9]</a> and uci_proxy_client.py<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/uci_proxy_client.py">[10]</a> scripts.</p>
        <p>In both modes, <em>partial dependence</em> plots<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L81">[11]</a> are periodically emitted in .png format along with actual/expected optima, and a clean log file is written. The log file can be used to resume<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L279">[12]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L307">[13]</a> parameter optimization if it is interrupted.</p>
        <p>GPUs can be shared by TensorFlow processes, and TensorFlow can be instructed to grow memory use on GPUs only as needed<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L307">[14]</a>. In contrast, Cloud TPU VM chips can only be held by a single process, complicating the technical design. When running tournament optimization, a separate path into Python code is used to avoid initializing TensorFlow<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/ChessCoach.cpp#L182">[15]</a>. During distributed optimization, each host can only be used for one ChessCoach instance<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/optimization.py#L58">[16]</a>, although Stockfish can be used<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/config.toml#L284">[17]</a> instead of baseline ChessCoach to halve the number of hosts required (or just to optimize to beat Stockfish). The proxy docker image binds to separate ports for these two engines<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/proxy.dockerfile#L13">[18]</a>.</p>
        <p>Because TPU initialization is very slow for every new process, taking up to 30 seconds, cutechess-cli times out by default. These timeouts are hardcoded, and the Qt framework overly complicates building, so the binary was modified directly by searching for the existing constants and changing the ping timeout from 15 seconds to 60 seconds<a href="https://github.com/chrisbutner/ChessCoach/commit/fa6fb490c26e37e1e37f3e686e2bf28e3f938aa5">[19]</a>.</p>

        <h2 id="bot">Bot</h2>
        <p>ChessCoach can run as a bot on the Lichess platform, with an official bot set up at <a href="https://lichess.org/@/PlayChessCoach">https://lichess.org/@/PlayChessCoach</a>.</p>
        <p>ChessCoach bot code<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L1">[1]</a> is based on the official implementation at <a href="https://github.com/ShailChoksi/lichess-bot">https://github.com/ShailChoksi/lichess-bot</a>, relying on the Lichess API described at <a href="https://lichess.org/api">https://lichess.org/api</a>. However, code for flexible management of various engines and their configuration has been removed, and code specific to ChessCoach has been added; for example, for posting commentary during play.</p>
        <p>The lichessbot.py script is treated as a combination code/config file. Since the script is not compiled before deployment, no other code cares about its configuration, and its configuration is often very narrowly relevant, it makes sense to integrate configuration with usage locally.</p>
        <p>The bot plays one game at a time, accepting rated and casual challenges, but preferring rated<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L811">[2]</a>. <em>Material odds</em> are accepted<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L74">[3]</a>, as long as the challenger's rating is sufficiently low for the type of piece(s) missing. The bot generates and posts commentary in spectator chat every 30 seconds<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L174">[4]</a>. It also <em>ponders</em>, thinking on the opponent's time.</p>
        <p>If idle for long enough, the bot sends challenges to other bots. A list of bots with a rating of 1800 or higher is gathered (bot ratings are compressed downwards on Lichess), and an opponent is randomly sampled<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L598">[5]</a>. Time control is also randomly sampled<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L619">[6]</a>.</p>
        <p>The ChessCoach engine runs in the same process as the bot code<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachBot/ChessCoachBot.cpp#L60">[7]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L841">[8]</a> to simplify process and threading management, pondering, and data marshaling, rather than using the UCI interface.</p>
        <p>A single thread runs the main bot loop<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L675">[9]</a>, listening to a single event queue<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L868">[10]</a>. This thread reacts to various events and also performs periodic upkeep<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L764">[11]</a>. Other threads watch the control stream<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L641">[12]</a>, watch the game stream<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L654">[13]</a>, perform the search in C++<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachBot/ChessCoachBot.cpp#L47">[14]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L564">[15]</a>, and post commentary asynchronously<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py#L804">[16]</a>. Each of these secondary threads reports back by posting events to the central queue.</p>
        <p>Chess-specific logic is left to C++ as usual, so the raw position, move and time control details are passed in to the <strong>BotSearch</strong> API method. <strong>BotSearch</strong> then determines whether to search or ponder<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L454">[17]</a>, and generates commentary if enough time remains<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L547">[18]</a>. When it is the bot's turn to move, the primary search thread calls back into Python directly to report the best move<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L2306">[19]</a>. Pondering does not use any UCI-specific logic: just a time-limited think on the opponent's position<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L506">[20]</a>, which helps extend the search tree.</p>
        <p>Time management is a particular concern for bot play because it is a <em>real-time</em> environment, with one player's clock always ticking. Rather than being allowed &quot;free time&quot; to prepare a position or deallocate memory via the <code>isready</code> UCI command, the bot must fit all of this into its thinking time. Additionally, there is network overhead and API throttling to worry about<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L461">[21]</a>. ChessCoach has trouble especially with search tree deallocation time because of its naïve Node array allocation<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/SelfPlay.cpp#L814">[22]</a> in support of multi-threaded tree search. This limits potential ponder time<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/PythonModule.cpp#L520">[23]</a> during the opponent's turn because the cleanup eats into ChessCoach's turn, and time is always more efficiently spent searching one ply deeper.</p>

        <h2 id="scraping">Scraping</h2>
        <p>The scrape.py utility is used to download publicly available chess games with commentary. It is intended for use with the <a href="https://www.scrapingbee.com/">ScrapingBee</a> service, although this can be swapped<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/scrape.py#L44">[1]</a> for another service, or for local handling of the technical details.</p>
        <p>It is best to disable path length limitations on Windows before use, to avoid problems with the Base32 encoding.</p>
        <p>HTML and PGN content is hierarchically cached on disk<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/scrape.py#L74">[2]</a> to save on service costs, using the Base32-encoded URL as a key. However, some content cannot be cached because it is paginated and orders the most recent content first.</p>
        <p>Once games have been downloaded, they can be combined and split into a smaller number of PGN files<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/scrape.py#L276">[3]</a>, ready to be passed to the ChessCoachPgnToGames utility using the <code>--commentary</code> flag<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachPgnToGames/ChessCoachPgnToGames.cpp#L96">[4]</a> in order to generate commentary training data.</p>

        <h2 id="unit-tests">Unit tests</h2>
        <p>Unit tests are implemented using the GoogleTest framework. Some significant or interesting examples are:</p>
        <ul>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTest/GameTest.cpp#L81">FlipSpecialMoves (GameTest)</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTest/MctsTest.cpp#L172">PrincipleVariation (MctsTest)</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTest/MctsTest.cpp#L495">PrepareExpandedRoot (MctsTest)</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTest/NetworkTest.cpp#L167">CompressDecompress (NetworkTest)</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTest/NetworkTest.cpp#L480">EvaluationColorSymmetry (NetworkTest)</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTest/PgnTest.cpp#L84">San and ParseSan (PgnTest)</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoachTest/PredictionCacheTest.cpp#L77">SumValidation (PredictionCacheTest)</a></li>
        </ul>

        <h2 id="build">Build</h2>
        <p>Linux and Windows use different build infrastructure, relying on Meson/Ninja/GCC<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/build.sh">[1]</a> and MSBuild<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/build.cmd">[2]</a> respectively. ChessCoach was primarily developed using Visual Studio and Visual Studio Code on Windows, so up-to-date solution<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach.sln">[3]</a> and project files are in place for Visual Studio. Python installation is more awkward on Windows, so virtual environment support is optional but more built-in for this platform<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/activate_virtual_env.cmd">[4]</a>.</p>
        <p>Building first requires dependency setup<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/setup.sh">[5]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/setup.cmd">[6]</a>.</p>
        <p>On Linux, protobuf 3.13.0 needs to be built and installed from source<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/setup.sh#L27">[7]</a>. Ubuntu 20.04 (Focal) and Debian 10 (Buster) are targeted, although Ubuntu 18.04 (Bionic) support can be found in prepare.sh (now setup.sh) and dockerfiles by syncing code back. TensorFlow setup varies between older-style TPUs and newer-style Cloud TPU VMs (see <a href="https://github.com/chrisbutner/ChessCoach#installation">Installation</a> in the README).</p>
        <p>On Windows a CHESSCOACH_PYTHONHOME<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/setup.cmd#L8">[8]</a> environment variable is set up to use when building<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/ChessCoach.vcxproj#L103">[9]</a>, and when initializing Python<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/ChessCoach.cpp#L98">[10]</a>.</p>
        <p>Stockfish is built in the 64-bit BMI2 configuration (USE_PEXT) but with prefetching disabled (NO_PREFETCH) as Stockfish search and transposition tables are not used<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/meson.build#L13">[11]</a><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Directory.Build.props#L4">[12]</a>.</p>
        <p><a href="#distributed-training-and-self-play">Distributed training and self-play</a> covers building and running docker images.</p>

        <h2 id="third-party-libraries">Third-party libraries</h2>
        <p>The following third-party C++ libraries are used:</p>
        <ul>
            <li>Bayeselo</li>
            <li>Cute Chess (cutechess-cli)</li>
            <li>Google CRC32C</li>
            <li>GoogleTest</li>
            <li>Hunspell</li>
            <li>Protocol Buffers (protobuf)</li>
            <li>Stockfish</li>
            <li>Templatized C++ Command Line Parser Library (TCLAP)</li>
            <li>TensorFlow</li>
            <li>toml11</li>
            <li>zlib</li>
        </ul>

        <p>The following third-party Python and JavaScript libraries are used:</p>
        <ul>
            <li>backoff</li>
            <li>Beautiful Soup</li>
            <li>chessboard.js</li>
            <li>cloud-tpu-client</li>
            <li>lichess-bot</li>
            <li>Matplotlib</li>
            <li>NumPy</li>
            <li>Requests</li>
            <li>Scikit-Optimize (skopt)</li>
            <li>SentencePiece</li>
            <li>TensorFlow Model Garden</li>
            <li>TensorFlow Text</li>
            <li>toml (uiri/toml)</li>
        </ul>

        <p>The following third-party data is used:</p>
        <ul>
            <li>LibreOffice dictionaries</li>
        </ul>

        <p>Modifications and extensions to third-party libraries have been made:</p>
        <ul>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Syzygy.cpp">Syzygy.cpp</a>/<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/ChessCoach/Syzygy.h">.h</a> extend <a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/syzygy/tbprobe.cpp">tbprobe.cpp</a>/<a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/syzygy/tbprobe.h">.h</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/transformer.py">Transformer.py</a> extends <a href="https://github.com/tensorflow/models/blob/r2.4.0/official/nlp/modeling/models/seq2seq_transformer.py">seq2seq_transformer.py</a> and <a href="https://github.com/tensorflow/models/blob/r2.5.0/official/nlp/tasks/translation.py">translation.py</a></li>
            <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/py/lichessbot.py">Lichessbot.py</a> extends <a href="https://github.com/ShailChoksi/lichess-bot">lichess-bot</a> (multiple files)</li>
            <li>
                Google CRC32C
                <ul>
                    <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/crc32c/src/crc32c_prefetch.h#L28">Definition usage is changed in crc32c_prefetch.h</a> to allow multiple platforms to build without manual configuration.</li>
                </ul>
            </li>
            <li>
                Stockfish
                <ul>
                    <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L78">Position copy constructor/assignment are undeleted</a>.</li>
                    <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L80">Position's StateInfo is publicly exposed</a>.</li>
                    <li>A more efficient method is implemented for <a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/position.h#L149">reapplying a move when its StateInfo has already been calculated</a>.</li>
                    <li><a href="https://github.com/chrisbutner/ChessCoach/blob/v1.0.0/cpp/Stockfish/types.h#L66">Redefinition of IS_64BIT is bypassed</a> since explicit definition is required for Linux and consistency is preferred.</li>
                </ul>
            </li>
        </ul>

        <p class="footer">Written 22 September 2021</p>
    </article>
</body>
</html>


