High priority
- make sure we can get to 500-step networks without exploding losses/gradients

Performance
- game/mcts timing is slightly skewed across training (@ResetGames)
- break down MCTS timing details just in case anything's off (C++ Profiler class?)
- can reserve the training ararys in C++ Storage once rather than per training
- think about caching - zobrist? - predictions within the same network (just keep at each game until it needs a new prediction)
- it might be faster to use 2-after-search-root repetition checks and throw away subtrees
  rather than use 3-repetition checks and keep them (even counting extra iterations)

Training quality
- add additional input planes (beyond just pieces) - make sure it's no less stable
- try to get tensorboard integrated despite the C++ stuff?
- save PGNs for non-draws (or just every N games, need to observe)

Code quality
- constant-ize the 12/X/73 everywhere
- unify config across C++/Python
- privatize C++ methods (got too python-brained)

Scalability
- can't afford 1 million games in the window (RAM or disk), work something out

C++
- Eventually modify stockfish - Position, etc. - so it doesn't reach out to uci/options/threads code at all
- Try Intel compiler in future

Python
- Add type info everywhere - look up best practices for linting etc.

Improvements
- Multi-thread MCTS, if not for self-play generation then for UCI play
	- "On the scalability of parallel UCT"
	- https://medium.com/oracledevs/lessons-from-alpha-zero-part-5-performance-optimization-664b38dc509e
- "Random move with eval within 1%"
	- http://blog.lczero.org/2018/12/alphazero-paper-and-lc0-v0191.html?m=1
	- https://kstatic.googleusercontent.com/files/2f51b2a749a284c2e2dfa13911da965f4855092a179469aedd15fbe4efe8f8cbf9c515ef83ac03a6515fa990e6f85fd827dcd477845e806f23a17845072dc7bd

UCI
- (New: Probably just wrap the C++ with UCI now? Can kill python-installer, etc.)
- Need to make TF/etc. silent
- Integrate sync-UCI hack with trained model
- Split out UCI thread so infinite think, ponder, etc. can workers
- Implement infinite think, ponder, time controls
- Implement endgame tablebases (invisible/external to the training loop?)
- Switch from python-chess to own board, movegen, etc. (or be sure of GPLv3 static vs. dynamic)

Low priority
- see if it's more efficient saving/loading checkpoints (measure save/load time, prediction time, disk savings)
